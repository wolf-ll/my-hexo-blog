---
title: 黑马点评
date: 2024-05-13 20:04:03
auther: 小狼
summary: Redis实战
categories: 后端
tags:
  - 项目
  - Redis
---

# 黑马点评

## MySQL表

* tb_user：用户表
* tb_user_info：用户详情表
* tb_shop：商户信息表
* tb_shop_type：商户类型表
* tb_blog：用户日记表（达人探店日记）
* tb_follow：用户关注表
* tb_voucher：优惠券表
* tb_voucher_order：优惠券的订单表

## 当前模型

手机或者app端发起请求，请求我们的nginx服务器，nginx基于七层模型走的是HTTP协议，可以实现**基于Lua直接绕开tomcat访问redis**，也可以作为**静态资源服务器**，轻松扛下上万并发， 负载均衡到下游tomcat服务器，打散流量，我们都知道一台4核8G的tomcat，在优化和处理简单业务的加持下，大不了就处理1000左右的并发， 经过nginx的负载均衡分流后，利用集群支撑起整个项目，同时nginx在部署了前端项目后，更是可以做到动静分离，进一步降低tomcat服务的压力，这些功能都得靠nginx起作用，所以nginx是整个项目中重要的一环。

在tomcat支撑起并发流量后，我们如果让tomcat直接去访问Mysql，根据经验Mysql企业级服务器只要上点并发，一般是16或32 核心cpu，32 或64G内存，像企业级mysql加上固态硬盘能够支撑的并发，大概就是4000起~7000左右，上万并发， 瞬间就会让Mysql服务器的cpu，硬盘全部打满，容易崩溃，所以我们**在高并发场景下，会选择使用mysql集群，同时为了进一步降低Mysql的压力，同时增加访问的性能，我们也会加入Redis，同时使用Redis集群对外提供更好的服务。**

## 用户鉴权

### Cookie

cookie 是一个非常具体的东西，指的就是浏览器里面能永久存储的一种数据，仅仅是浏览器实现的一种数据存储功能。

cookie由服务器生成，发送给浏览器，浏览器把cookie以kv形式保存到某个目录下的文本文件内，下一次请求同一网站时会把该cookie发送给服务器。

由于cookie是存在客户端上的，所以浏览器加入了一些限制确保cookie不会被恶意使用，同时不会占据太多磁盘空间，所以每个域的cookie数量是有限的。

**Cookie 技术主要用于：**

* 身份验证：保存用户登录状态，实现持久登录。
* 会话管理：追踪用户的会话信息，例如购物车内容。
* 个性化设置：存储用户偏好设置，以提供个性化的用户体验。

Cookie 的相关操作和属性可以通过 JavaScript 的 document.cookie 对象进行访问和修改。可以设置 Cookie 的**过期时间、作用域、路径**等属性，以控制其有效性和访问范围。

### Session

Session（会话）是一种**在服务器端存储用户状态和数据的机制**。它通过在服务器端创建一个唯一的会话标识（通常是一个 Session ID），并将该标识发送给客户端，实现在不同的请求中跟踪和管理用户的状态。

当用户访问一个网站时，服务器会为该用户创建一个会话，并将会话 ID 存储在 Cookie 中，或者通过其他方式将其发送给客户端。客户端的浏览器会自动在后续的请求中**将会话 ID 发送给服务器，在服务器端找到对应的会话数据。**

会话数据存储在服务器端的临时存储区域，通常是在服务器的内存中或在数据库中。服务器会根据会话 ID 来检索和更新相应的数据，从而实现用户状态的管理和维护。

**Session 技术的主要作用：**

* 身份验证：存储用户登录信息和权限，实现用户认证。
* 会话管理：追踪用户的操作和活动，在请求之间保持连续性。
* 数据存储：存储用户数据，例如购物车、表单数据等。

需要注意的是，为了保护用户数据的安全性和隐私，开发人员应采取适当的安全措施：

* 使用安全的传输协议（如 HTTPS）来保护会话数据在网络传输中的安全性。
* 针对会话 ID 的保护，包括生成安全的随机会话 ID、设置合适的过期时间，以及通过 HttpOnly 和 Secure 标志来防止跨站脚本攻击和会话劫持。

### Token

Token（令牌）是一种**在身份验证和授权中使用的字符串**，用于验证客户端的身份和权限。它作为客户端和服务器之间进行安全通信的一种方式，来确保用户的身份和访问权限。

Token 的主要特点是它是**无状态**的，**即服务器不需要在存储设备中维护任何信息**。服务器在生成 Token 后，将其发送给客户端，客户端在以后的请求中将 Token 作为身份凭证发送给服务器。服务器通过验证 Token 的有效性，来确认客户端的身份和权限。

Token 的生成和验证过程一般包含以下步骤：

* 客户端向服务器发送身份验证请求，通常是提供用户名和密码。
* 服务器验证客户端提供的身份信息，并生成一个 Token。
* 服务器将生成的 Token 发送给客户端，客户端将其保存。
* 客户端在以后的请求中将 Token 添加到请求头中，作为身份凭证。
* 服务器在接收到请求时，验证 Token 的有效性和权限，并相应地处理请求。

**Token 的主要作用：**

* 身份验证：通过 Token 来验证客户端的身份，替代传统的基于会话的身份验证机制，不需要在服务器端存储会话信息，减轻服务器的负担。
* 授权：服务器可以根据 Token 中的信息来判断客户端的权限，决定是否允许相应的操作。
* 单点登录（SSO）：Token 可以在不同的应用程序之间共享，实现用户的单点登录功能。

Token 可以有不同的类型和格式，常见的包括 JSON Web Token（JWT）、OAuth 2.0 的访问令牌等。同时，Token 也可以通过加密和签名等方式来保证其安全性。

## 短信登录

### 发送验证码

> 1、用户提交手机号
> 2、校验手机号是否合法
> 3、生成验证码
> 4、将生成的验证码保存到session中，用于后续的验证
> 5、发送验证码给用户


**接口地址**:`/user/code`

**请求方式**:`POST`

**请求数据类型**:`application/json`

**请求参数**:


| 参数名称 | 参数说明 | 请求类型 | 是否必须 | 数据类型    | schema |
| -------- | -------- | -------- | -------- | ----------- | ------ |
| phone    |          | query    | true     | string      |        |
| session  |          | query    | true     | HttpSession |        |


**响应示例**:
```javascript
{
	"data": {},
	"errorMsg": "",
	"success": true,
	"total": 0
}
```

### 登录/注册

> 1、提交手机号和验证码
> 2、校验验证码
> 3、根据手机号查询数据库信息
> 4、用户存在就保存到session，否则就创建新用户并保存到数据库，最后也保存到session中


**接口地址**:`/user/login`


**请求方式**:`POST`

**请求数据类型**:`application/json`

**请求参数**:


| 参数名称             | 参数说明  | 请求类型 | 是否必须 | 数据类型     | schema       |
| -------------------- | --------- | -------- | -------- | ------------ | ------------ |
| loginForm            | loginForm | body     | true     | LoginFormDTO | LoginFormDTO |
| &emsp;&emsp;code     |           |          | false    | string       |              |
| &emsp;&emsp;password |           |          | false    | string       |              |
| &emsp;&emsp;phone    |           |          | false    | string       |              |
| session              |           | query    | true     | HttpSession  |              |

### 校验登录状态-拦截器

首先我们要知道怎么基于session进行校验，session是基于cookie的（每一个session的id都会保存到cookie中），当用户访问的时候会携带cookie，所以我们可以根据cookie中的session_id来查询session中是否有这个用户：

> 1、用户发送请求并携带cookie
> 2、从session中获取用户
> 3、判断用户是否存在：
> （1）没有这个用户就拦截
> （2）有这个用户就保存用户信息到ThreadLocal用于登录缓存（ThreadLocal是一个线程域对象，**每一个请求到达服务都会是一个独立线程，直接保存到本地变量会出现并发修改的安全问题，而ThreadLocal会将数据保存到每个线程内部，在线程内部创建一个Map来进行保存**），保存完后就放行该用户即可

基于session校验需要**在跨各种组件和页面的时候都访问session，编写重复的校验代码**，增加了访问session的开销。所以使用ThreadLocal，使得每一个线程只需要访问一次session。

```java
@Configuration
public class MvcConfig implements WebMvcConfigurer {
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(new LoginInterceptor())
                .excludePathPatterns(   // 白名单
                        "/shop/**",
                        "/shop-type/**",
                        "/voucher/**",
                        "/upload/**",
                        "/blog/hot",
                        "/user/code",
                        "/user/login"
                );
    }
}

public class LoginInterceptor implements HandlerInterceptor {

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        // 获取客户端请求传进来的session
        HttpSession session = request.getSession();
        // 获取user
        Object user = session.getAttribute("user");
        // 用户不存在，拦截，返回401状态码
        if (user == null) {
            response.setStatus(401);
            return false;
        }
        // 用户存在session中，保存到localthread，放行
        UserHolder.saveUser((UserDTO) user);
        return true;
    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        // 线程执行后移除用户
        UserHolder.removeUser();
    }
}
```

### 集群的session共享问题

**session共享问题：多台Tomcat并不共享session存储空间，当请求切换到不同Tomcat服务时导致数据丢失的问题。**
这是因为我们为了我们将来系统的**高并发性**，就需要**水平拓展，形成负载均衡的集群**，**每个Tomcat都会有一个对应的session。当我们在某一台Tomcat上进行登录以后，第二次登录的时候，要是被负载均衡到了另一台Tomcat，就会造成没办法获得之前登录时的session，就没办法再做验证了。**
这个问题听起来好像也挺容易解决，如果每台Tomcat都互相拷贝，保存相同的数据，那肯定就不至于发生如上的问题，但是这样的解决方式太浪费空间了，而且拷贝的过程还是比较费时的，如果这时候已经有访问请求，就可能会出现数据不一致的情况。
因此，我们的session信息共享的解决方案应该满足以下特点：
**1、数据共享**
2、内存存储
3、key-value结构
这时候我们就回到了Redis了，我们知道Redis是独立于Tomcat的，单独进行存储，且任何一台Tomcat都可以访问到Redis，因此可以实现数据共享

#### 基于Redis实现共享session

##### 发送验证码

验证码保存到redis中，Redis的结构是key-value的，且value是很多种类型的，在这里我们选择最简单的String类型即可。

> 一个需要考虑的问题是key的选取，在session中我们选用了“code”来作为key，但在这里却不行。这是因为**每一个不同的浏览器在发送请求的时候都会有一个不同的独立的session，也就是说Tomcat的内部维护了很多的session，互相之间是不会干扰的**。但是Redis是一个共享的内存空间，如果直接使用key会造成**覆盖**，所以我们不能直接选用“code”来作为key。因此我们可以**用手机号作为key（因为同一账号同一时刻仅在一个平台登录）。**
>

```java
@Resource
private StringRedisTemplate stringRedisTemplate;

@Override
public Result sendCode(String phone, HttpSession session) {
    // 校验手机号，正则，不合法则返回错误信息
    if (RegexUtils.isPhoneInvalid(phone)) {
        return Result.fail("手机号格式错误");
    }
    // 生成验证码
    String code = RandomUtil.randomNumbers(6);
    // 保存验证码到redis，用phone为key，限制有效期5min
    //        session.setAttribute("code", code);  这个是存到session
    stringRedisTemplate.opsForValue().set(LOGIN_CODE_KEY+phone, code, LOGIN_CODE_TTL, TimeUnit.MINUTES);
    // 发送验证码，调用第三方平台
    log.debug("发送验证码：" + code);
    return Result.ok();
}
```

##### 验证码登录与注册

最终的用户信息不再保存到session中，而是保存都Redis中去了，同样要考虑key跟value的选择：
（1）value的选取：我们要保存的是用户的信息，这是一个对象。我们用Hash结构是最合适的。
（2）key的选取：这里并不建议用phone作为key，而是**以随机token（服务器生成的令牌）为key来存储用户数据**，因为**这里的token要存到前端，使用手机号为key不安全，容易泄露。**

在之前我们校验登录状态的时候，是从cookie中获取session再得到用户信息，而现在我们校验登录的时候**要访问的凭证就是这个随机token了**，但Tomcat不会将这个token自动写到浏览器上面。所以我们**把数据保存到Redis以后还需要手动的把token返回到前端**，流程就得修改：

> 1、提交手机号和验证码
> 2、校验验证码
> 3、根据手机号查询用户信息
> 4、**用户保存到Redis**
> 5、**返回token给客户端（重要一步）**

```java
@Override
public Result login(LoginFormDTO loginForm, HttpSession session) {
    String phone = loginForm.getPhone();
    // 校验手机号
    if (RegexUtils.isPhoneInvalid(phone)) {
        return Result.fail("手机号格式错误");
    }
    // 校验验证码，从redis中获取验证码
    //        Object cacheCode = session.getAttribute("code");
    String cacheCode = stringRedisTemplate.opsForValue().get(LOGIN_CODE_KEY + phone);
    String code = loginForm.getCode();
    // 不一致，报错
    if (cacheCode == null || !cacheCode.toString().equals(code)) {
        return Result.fail("验证码错误");
    }
    // 一致，查数据库tb_user
    User user = query().eq("phone", phone).one();
    // 不存在，创建新用户
    if (user == null) {
        user = createUserWithPhone(phone);
    }
    // 保存用户信息DTO(id，昵称，头像信息)到redis，需要生成token
    String token = UUID.randomUUID().toString();
    UserDTO userDTO = BeanUtil.copyProperties(user, UserDTO.class);
    // 将user对象转为map类型，拆分所有字段，以哈希结构存到redis里 -- 对象中的数据类型都应该是string
    Map<String, Object> userMap = BeanUtil.beanToMap(userDTO, new HashMap<>(),  // 将Java对象（Bean）转换为Map类型
                                                     CopyOptions.create()    // 对象转换时的配置项
                                                     .setIgnoreNullValue(true)   // 是否忽略空值，当源对象的值为null时，true: 忽略而不注入此值，false: 注入null
                                                     .setFieldValueEditor((fieldName, fieldValue) -> fieldValue.toString()));    // 对转换过程中的字段值进行编辑处理，对象值转为string
    String user_token = LOGIN_USER_KEY + token;
    // 这里long id直接转string会报错
    stringRedisTemplate.opsForHash().putAll(user_token, userMap);
    // 设置token有效期（超过30分钟没有访问就删除）
    stringRedisTemplate.expire(user_token, LOGIN_USER_TTL, TimeUnit.MINUTES);
    //        session.setAttribute("user", BeanUtil.copyProperties(user, UserDTO.class));
    return Result.ok(token);
}
```

<img src="黑马点评\image-20240515164315155.png">

##### 校验登录状态

我们不再是从浏览器中的cookie指定的session来获取用户信息，而是以随机token为key来从Redis中获取信息，流程如下：

> 1、用户发送请求并**携带token**
> 2、从Redis中获取用户（以随机token为key）
> 3、判断用户是否存在：
> （1）没有这个用户就拦截
> （2）有这个用户就保存用户信息到ThreadLocal，并放行

```java
public class LoginInterceptor implements HandlerInterceptor {
    // 这个拦截器类不是由spring管理的，所以需要手动构造stringRedisTemplate而不能用依赖注入
    // 通过调用该类的spring类注入stringRedisTemplate，然后传递参数到拦截器来完成构造
    private StringRedisTemplate stringRedisTemplate;

    public LoginInterceptor(StringRedisTemplate stringRedisTemplate) {
        this.stringRedisTemplate = stringRedisTemplate;
    }
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        // 获取客户端请求头传进来的token
        String token = request.getHeader("authorization");
//        HttpSession session = request.getSession();
        // token为空或仅包含空白字符
        if (StrUtil.isBlank(token)) {
            response.setStatus(401);
            return false;
        }
        // 基于token构造redis中存的用户信息的key
        String key = RedisConstants.LOGIN_USER_KEY + token;
        // 基于token获取redis中存的user
        Map<Object, Object> userMap = stringRedisTemplate.opsForHash().entries(key);
        // 用户不存在，拦截，返回401状态码
        if (userMap.isEmpty()) {
            response.setStatus(401);
            return false;
        }
        UserDTO userDTO = BeanUtil.fillBeanWithMap(userMap, new UserDTO(), false);
        // 用户存在，保存到localthread，放行
        UserHolder.saveUser(userDTO);
        // 更新过期时间 -- 也就是每次访问新的页面，进行拦截器判断，更新过期时间
        stringRedisTemplate.expire(key, RedisConstants.LOGIN_USER_TTL, TimeUnit.MINUTES);
        return true;
    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        // 线程执行后移除用户
        UserHolder.removeUser();
    }
}
```

##### 解决状态登录刷新的问题——登录拦截器的优化

上述代码实现完还有一点小问题，之前的拦截器并不会拦截掉一切路径，而是所有需要登录的路径，那么会出现一个问题：我们的首页并不需要登录就可以直接访问，那么**已经登录过的用户一直在首页进行操作，拦截器中的登录状态并不会刷新，就可能造成明明一直在操作系统，却被视为不算是在登录状态。**
解决方法是**再加上一个拦截器，用户的请求要先经过这个拦截器，这个拦截器会拦截一切的路径，所以我们可以在这个拦截器里面进行token有效期的刷新操作：**

> 1、获取token
> 2、查询Redis的用户
> 3、保存到ThreadLocal
> 4、刷新token有效期
> 5、放行

这样的话，一切的请求都会触发刷新的操作。那么**之前的拦截器只需要查询ThreadLocal的用户，存在则继续，不存在则拦截。**

新的拦截一切的拦截器做用户校验，存到threadlocal并放行一切：

```java
@Override
public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
    // 获取客户端请求头传进来的token
    String token = request.getHeader("authorization");
    // token为空或仅包含空白字符，直接放行
    if (StrUtil.isBlank(token)) {
        return true;
    }
    // 基于token构造redis中存的用户信息的key
    String key = RedisConstants.LOGIN_USER_KEY + token;
    // 基于key获取redis中存的user
    Map<Object, Object> userMap = stringRedisTemplate.opsForHash().entries(key);
    // 用户不存在，直接放行
    if (userMap.isEmpty()) {
        return true;
    }
    UserDTO userDTO = BeanUtil.fillBeanWithMap(userMap, new UserDTO(), false);
    // 用户存在，保存到localthread，更新放行
    UserHolder.saveUser(userDTO);
    // 更新过期时间
    stringRedisTemplate.expire(key, RedisConstants.LOGIN_USER_TTL, TimeUnit.MINUTES);
    return true;
}
```

旧的拦截器只检查threadlocal有没有用户：

```java
@Override
public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
    // 在login拦截器中只需要校验threadlocal里面有没有存用户，没有则拦截
    if (UserHolder.getUser() == null) {
        response.setStatus(401);
        return false;
    }
    return true;
}
```

## 商户查询缓存

### 什么是缓存

缓存：数据交换的缓冲区（Cache），是**存储数据的临时地方，读写性能高。**俗称的缓存就是**缓冲区内的数据**,一般从数据库中获取,存储于本地代码(例如:

```java
例1:Static final ConcurrentHashMap<K,V> map = new ConcurrentHashMap<>(); 本地用于高并发
例2:static final Cache<K,V> USER_CACHE = CacheBuilder.newBuilder().build(); 用于redis等缓存
例3:Static final Map<K,V> map =  new HashMap(); 本地缓存
```

由于其被**Static**修饰,所以随着类的加载而被加载到**内存之中**,作为本地缓存,由于其又被**final**修饰,所以其引用(例3:map)和对象(例3:new HashMap())之间的关系是固定的,不能改变,因此不用担心赋值(=)导致缓存失效;

我们的浏览器有浏览器缓存，在浏览器未命中数据，就会在tomcat的应用层缓层中取数据，再没有命中的话就去数据库进行查询检索。
**缓存的作用：**
1、降低后端负载
2、提高读写效率，降低响应时间
**缓存的成本：**
1、数据的一致性成本
2、代码维护成本（解决一致性问题的时候带来的代码复杂）
3、运维的成本

### 商户查询添加缓存

如果直接查数据库，逻辑是这样的。速度慢

```java
@GetMapping("/{id}")
public Result queryShopById(@PathVariable("id") Long id) {
    //这里是直接查询数据库
    return shopService.queryById(id);
}
```

改成缓存，用string类型存商户json信息

```java
@Override
    public Result queryById(Long id) {
        // 查缓存，若存在直接返回，不存在就查数据库
        String key = CACHE_SHOP_KEY + id;
        String shopJson = stringRedisTemplate.opsForValue().get(key);
        if (StrUtil.isNotBlank(shopJson)) {
            // 存在店铺信息，反序列化json为bean对象并返回
            Shop shop = JSONUtil.toBean(shopJson, Shop.class);
            return  Result.ok(shop);
        }
        // 查数据库
        Shop shop = getById(id);
        if (shop == null)
            return Result.fail("店铺不存在");
        // 数据库中存在，将店铺信息序列化为json字符串，存储到redis缓存中
        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(shop));
        return Result.ok(shop);
    }
```

### 商户类型序列缓存

shopTypeController

```java
@GetMapping("list")
public Result queryTypeList() {
    //        List<ShopType> typeList = typeService
    //                .query().orderByAsc("sort").list();
    return typeService.queryShopTypeList();
}
```

shopTypeServiceImpl

```java
@Service
public class ShopTypeServiceImpl extends ServiceImpl<ShopTypeMapper, ShopType> implements IShopTypeService {
    @Resource
    StringRedisTemplate stringRedisTemplate;
    @Override
    public Result queryShopTypeList() {
        // 要返回的商户列表
        List<ShopType> typeList = new ArrayList<>();
        // 存到redis中的商户类型list，是商户这个类型的json字符串的list集合
        List<String> redisTypeList = new ArrayList<>();

        // 查询redis缓存
        Long size = stringRedisTemplate.opsForList().size(CACHE_SHOPTYPE_KEY);
        if (size != 0) {    // 缓存有数据就返回
            redisTypeList = stringRedisTemplate.opsForList().range(CACHE_SHOPTYPE_KEY, 0, size);
            // 利用stream流和map将string类型的json list转换为bean list
            typeList = redisTypeList.stream().map(s->{
                return JSONUtil.toBean(s, ShopType.class);
            }).collect(Collectors.toList());
            return Result.ok(typeList);
        }

        // 缓存没有，查数据库，存缓存，返回
        typeList = query().orderByAsc("sort").list();
        
        if (typeList == null || typeList.isEmpty())
            return Result.fail("不存在商户类型数据");

        // 查到的bean list通过stream流转为string list，存到缓存
        redisTypeList = typeList.stream().map(shopType->{
            return JSONUtil.toJsonStr(shopType);
        }).collect(Collectors.toList());
        stringRedisTemplate.opsForList().rightPushAll(CACHE_SHOPTYPE_KEY, redisTypeList);

        return Result.ok(typeList);
    }
}
```

## 缓存更新策略

上面的作用模型可能会造成数据一致性问题，当我们对数据库进行修改的时候，缓存并没有同步进行修改，页面在缓存中获取数据的时候，其实并不是最新的数据。这肯定是不允许的。

下面是缓存更新策略：

|          |                           内存淘汰                           |                           超时剔除                           |                    主动更新                    |
| -------- | :----------------------------------------------------------: | :----------------------------------------------------------: | :--------------------------------------------: |
| 说明        | 不用自己维护，利用Redis的内存淘汰机制，**内存不足时自动淘汰部分数据**，下次查询时更新缓存 | 给缓存数据添加TTL时间，**到期后自动删除缓存**。下次查询即可实现缓存的更新 | 自己编写业务逻辑，在修改数据库的同时，更新缓存 |
| 一致性      |                              差                              |                             一般                             |                       好                       |
| 维护成本    |                              无                              |                              低                              |                       高                       |

上述的策略选择要根据具体的业务场景：
1、低一致性需求/数据很少更新：使用内存淘汰机制。例如店铺类型的查询缓存。
2、高一致性需求：**主动更新，以超时剔除作兜底方案。例如店铺详情查询的缓存。**

### 主动更新策略

1、**Cache Aside Pattern（最常用）** -- 由缓存的调用者，在更新数据库的同时更新缓存
2、**Read/Write Through Pattern** -- 缓存与数据库整合为一个**服务**，由服务来维护一致性（调用者不知道服务内部）。调用者调用该服务无需关注一致性问题。但这种服务的成本肯定是很高的。
3、**Write Behind Caching Pattern（写回）** -- 调用**者只操作缓存**，**由其它线程异步的将缓存数据持久化到数据库**，保证最终一致。
比如我们一直对缓存进行更新，更新10次以后轮到这个线程工作，就维护一下数据库的数据为更新10次后的数据，中途的其他9次更新操作根本不重要，这样的**性能显然是很高的**。这种方式当然也有很大问题，比如**长期的数据不一致、缓存宕机造成的严重后果**等。

操作缓存和数据库时要考虑如下几个问题：

  - 删除缓存还是更新缓存？ 	
      - 更新缓存：每次更新数据库都更新缓存，**无效写操作较多**。（写多读少的情况，假设更新100次数据，读1次数据，这边会有100次无效更新缓存）	
      - 删除缓存：**更新数据库时让缓存失效，查询时再更新缓存**（**更优**） 。（写多读少时，更新100次也只需要删一次缓存，避免无效写操作）
  - 如何保证缓存和数据库的操作的同时成功或失败？（原子性） 	
        - 单体系统：**事务控制**，将缓存与数据库操作放在一个事务 	
        - 分布式系统：利用TCC等**分布式事务方案** 
  - 先操作缓存还是先操作数据库？（线程安全） 	
        - 先删除缓存，再操作数据库 	
        - 先操作数据库，再删除缓存 	- 由于 redis 的速度远比MySQL要快，所以方案二为优选

**先删缓存再操作数据库的线程安全问题：**正常情况如左图，两个线程得到的数据一致。异常情况下如果线程2（读操作）在线程1写数据库之前查缓存，就会使得缓存与数据库不同步。因为写MySQL数据库操作比查Redis缓存操作慢，所以异常情况很容易发生。

<img src="黑马点评\image-20240516121851596.png" style="zoom:80%;" >

**先操作数据库再删缓存的线程安全问题**：正常情况如左图。异常情况如右图。异常情况发生条件是（1）线程并行（2）缓存失效（3）在线程1（读操作）查数据库过程中，线程2完成了更新数据库和删缓存两个操作。由于MySQL写数据比查数据慢，在微秒级别内完成更新数据库和删除缓存概率很低。所以这个方式更好。

<img src="黑马点评\image-20240516122155989.png" alt="image-20240516122155989" style="zoom:80%;" />

### 总结Redis读写策略

读操作：

* 缓存命中则直接返回
* 缓存未命中则查询数据库，并写入缓存，设定超时时间

写操作：
* **先写数据库，然后再删除缓存**
* 要确保数据库与缓存操作的原子性

## 商铺缓存与双写一致

现在我们要给查询商铺的缓存添加**主动更新**和**超时剔除**策略。
修改ShopController的业务逻辑满足：
（1）根据id查询店铺，没命中就查数据库，然后写入缓存，**并设置超时时间**
（2）根据id**修改**店铺，**先操作数据库，再删除缓存**

```java
@Override
@Transactional  // 通过事务控制数据库和缓存操作的原子性
public Result update(Shop shop) {
    Long id = shop.getId();
    if (id == null)
        return Result.fail("店铺不存在");
    // 更新数据库
    updateById(shop);
    // 删除缓存
    stringRedisTemplate.delete(CACHE_SHOP_KEY + id);
    return Result.ok();
}
```

## 缓存穿透、雪崩、击穿

### 缓存穿透

**缓存穿透**是指**客户端请求的数据在缓存和数据库中都不存在**，这样缓存永远不会生效，这些请求都会打到数据库。不断发起这样的请求，给数据库带来巨大压力。过程即：
（1）客户端访问Redis，未命中	（2）接着访问数据库，未命中
这样的话，如果有人恶意多线程地访问不存在的内容，可能就把我们的系统弄垮了。

#### 解决方案

**1、缓存空对象：**
（1）客户端请求Redis，未命中
（2）接着访问数据库，未命中
（3）**数据库将空值null缓存到Redis里**
这样如果继续访问的话，**就会访问Redis了，不会一直去对数据库造成攻击**，尽管访问Redis以后返回的内容是NULL。
**优点**：实现简单，维护方便
**缺点**：**额外内存消耗**（每次进行不同的访问，都创建null，不过设置TTL可以解决）；可能**造成短期的不一致**（设置为NULL之后，数据库真的新增了这个数据，不过设置TTL可以有效缓解这种情况的出现概率）

**2、布隆过滤：**
这其实是一种算法，它**在客户端与Redis交互之间加了一个布隆过滤器**：
（1）用户请求布隆过滤器，**不存在就直接拒绝**
（2）存在的话就放行，让客户端去访问Redis，有就返回，没有就访问数据库
布隆过滤器存储的一系列的二进制位，**这种二进制数是先对数据库数据进行某种哈希运算以后再转成二进制存储到布隆过滤器的**，具体原理可以自行查询，这种算法实现方式决定了**过滤器存在概率性**：如果过滤器返回**不存在**，那就是不存在；如果返回**存在**，那就不一定了。

**优点**：**内存占用较少**，没有多余key
**缺点**：实现复杂（不过Redis里面存在，可以简化开发）；存在**误判可能**。

因为布隆过滤器存在误判，所以我们的开发过程中，会选择**缓存空对象**的方式来解决缓存穿透。

<img src="黑马点评\image-20240516130239055.png" alt="image-20240516130239055"  />

**缓存穿透的其他解决方案：**

* 增强id的复杂度，避免被猜测id规律
* 做好数据的基础格式校验
* 加强用户权限校验
* 做好热点参数的限流

### 解决商铺查询的缓存穿透问题

1、我们需要在之前业务流程环节中增加缓存空对象的环节，即可解决，也就是根据id查询数据库的时候，判断商铺不存在之后，不再直接结束，而是将空值写入Redis。
2、那么我们之后的查询，可以在缓存中查询出null值，因此我们的查询就需要对查询出来的值进行判断，不是空值的话才能返回商铺信息到前端。

<img src="黑马点评\image-20240516214714449.png" alt="image-20240516214714449" style="zoom:80%;" />

### 缓存雪崩

**缓存雪崩**是指在同一时段**大量的缓存key同时失效或者Redis服务宕机**，导致大量请求到达数据库，带来巨大压力。

正常情况下，大量请求会到达Redis，少数请求到达数据库。而Redis一旦宕机，或者Redis中的大量key都因为TTL到期而失效了，这时候的很多请求都会指向数据库。
针对这个问题，我们可以提出一些解决方案：
1、给不同的key的**TTL添加随机值**，避免大量的key在同一个小时段内失效
2、利用**Redis集群**提高服务的可用性（Redis哨兵机制可以实现服务的监控，**发现宕机的主Redis，就可以立刻将从Redis替代上去**），这个内容相对比较高级，在之后讲。
3、给**缓存业务添加降级限流策略（微服务部分）**（如果整个集群的Redis全部都宕机了，我们可以提前做容错处理，当这些Redis都失效的时候，我们要**及时的拒绝请求**，防止大量请求到达数据库）
4、给业务添加**多级缓存**

### 缓存击穿

**缓存击穿**也叫作热点key问题，就是一个被**高并发访问**并且**缓存重建业务较复杂**的key突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击。

> 我们可以这么理解，网站中有一些内容是非常的重要的，很可能**在同一时段被多个用户给同时访问，也就是高并发访问**，而这个**被高并发访问的key失效了，这时候访问就会到达数据库**，大量请求到达数据库是很危险的，很容易造成缓存雪崩。
> 即便数据库比较坚强，也有可能用户进行访问的内容是很复杂的，可能涉及到了多表查询，也可能其转换到Redis中进行存储的时候需要进行一系列的业务。当缓存重建业务复杂的时候，如此大的请求在那一瞬间给数据库带来的冲击是非常巨大的。

缓存击穿问题，有两种比较主流的解决方法：
1、互斥锁
2、逻辑过期

#### 互斥锁

1、当第一个线程**未命中缓存**的时候，**获取互斥锁，直到这个线程查询数据库完，并且重建了缓存数据并存入Redis，才能释放互斥锁；**
2、后面的线程在缓存数据存入Redis的过程中，同样会发生查询Redis未命中的情况，那么这些线程无法获得互斥锁，只能进行**休眠，休眠一段时间后再重试，直到锁被解开**（Redis中已经有数据了）。

#### 逻辑过期

缓存击穿会出现的原因，其实无非就是TTL到期，Redis失效了，因此我们可以**不给其设置TTL**。但是我们该如何知道key过期了呢？我们要给这个key设置一个逻辑过期，类似：

| KEY        | VALUE                                |
| ---------- | ------------------------------------ |
| wxj:user:1 | {name:“Jack”, age:21, expire:151467} |

这里的expire不是TTL，而是我们添加到Redis之前设定的，用**代码逻辑来进行维护**。

那么这个key一旦存储到了Redis里面，没有任何干预的情况下是永不过期的。

也就是说有线程在查询缓存的时候，代码逻辑里发现**逻辑时间过期了，我们也直接把旧数据返还给客户端**，同时数据更新交给另一个线程去做。此时有更多线程要查缓存，因为拿不到锁所以直接返回旧数据，避免了等待。

毕竟已经是高并发，一时的旧数据在很多时候也能接受，在我看来这是一种牺牲策略，客户端无须等待新数据到来，当然了，**旧数据迟早要进行修改，但数据的更新操作完全可以交给其他线程，这样可以提高效率**。

#### 总结

| 解决方案 | 优点                                   | 缺点                                       |
| -------- | -------------------------------------- | ------------------------------------------ |
| 互斥锁   | 没有额外内存消耗；保持一致性；实现简单 | 线程要等待，性能受影响；可能死锁           |
| 逻辑过期 | 线程无需等待，性能较好                 | **不保证一致性**；有额外内存消耗；实现复杂 |

<img src="黑马点评\image-20240516215835297.png" alt="image-20240516215835297" style="zoom:80%;" />

### 解决商铺查询的缓存击穿问题

加互斥锁。获取锁与释放锁的方法定义如下：

```java
private boolean tryLock(String key) {
    // 利用redis setnx - 向Redis中添加一个key，只用当key不存在的时候才添加并返回1
    Boolean flag = stringRedisTemplate.opsForValue().setIfAbsent(key, "1", 10, TimeUnit.SECONDS);
    // 直接返回flag的话，拆箱可能拿到空指针
    return BooleanUtil.isTrue(flag);
}

private void unlock(String key) {
    stringRedisTemplate.delete(key);
}
```

整合了缓存穿透和缓存击穿的代码。和前面的代码相比主要是在没有命中缓存，且没有存储空值的情况下，**在查数据库前要先获取互斥锁。防止多个线程同时打到数据库。**拿到锁以后查了数据库同步重建缓存返回数据，也就是这个线程的任务完成后，**才能释放锁给其他线程用**

```java
private Shop queryWithMutex(Long id) {
    // 查缓存，若存在直接返回，不存在就查数据库
    String key = CACHE_SHOP_KEY + id;
    String shopJson = stringRedisTemplate.opsForValue().get(key);
    if (StrUtil.isNotBlank(shopJson)) {
        // 存在店铺信息，反序列化json为bean对象并返回
        Shop shop = JSONUtil.toBean(shopJson, Shop.class);
        return  shop;
    }
    // 如果没有命中缓存。命中空值，也就是shopJson是“” 空字符串，而非null，返回错误
    if (shopJson != null) {
        return null;
    }

    // ====== 没缓存，没空值，需要查数据库 -- 查之前先尝试获取互斥锁，拿到锁以后才能查数据库 ======
    String lockKey = "lock:shop:" + id; // 每个商户都对应一个锁
    try {
        boolean isLock = tryLock(lockKey);
        // 判断是否获取成功
        if (!isLock){   // 失败则休眠并重试（递归）
            Thread.sleep(50);   // 单位：ms
            // 如果担心递归造成爆栈，可以用循环，一样的
            return queryWithMutex(id);
        }
        // 拿到了锁，查数据库
        Shop shop = getById(id);
        // 模拟重建的延时，测试用
        Thread.sleep(200);

        if (shop == null) {
            // 空值有效期相对更短
            stringRedisTemplate.opsForValue().set(key, "", CACHE_NULL_TTL, TimeUnit.MINUTES);
            return null;

        }
        // 数据库中存在，将店铺信息序列化为json字符串，存储到redis缓存中，并添加超时剔除
        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(shop), CACHE_SHOP_TTL, TimeUnit.MINUTES);
        return shop;
    } catch (InterruptedException e) {
        throw new RuntimeException(e);
    }finally {
        unlock(lockKey);    // 释放锁
    }
}
```

使用Jmeter做并发测试，设定并发量为1000。配置好路径和接口。

<img src="黑马点评\image-20240516223930023.png" alt="image-20240516223930023" style="zoom: 80%;" />

运行完以后打开查看结果树：

<img src="黑马点评\image-20240516224240314.png" alt="image-20240516224240314" style="zoom:80%;" />

打开汇总报告可以看到我们的吞吐量为204

<img src="黑马点评\image-20240516224424100.png" alt="image-20240516224424100" style="zoom:80%;" />

如此大的数据量打下去，但是我们的日志显示我们的数据库只执行了一次的查询语句：

<img src="黑马点评\image-20240516224134785.png" alt="image-20240516224134785" style="zoom:80%;" />

说明我们已经使用互斥锁成功避免了缓存击穿。

## 参考

黑马程序员Redis部分资料

Cookie、Session、Token概念、区别、如何实现：https://blog.csdn.net/weixin_44369049/article/details/132062232

CSDN博主布布要成为最负责的男人笔记：https://blog.csdn.net/m0_52380556?type=blog

